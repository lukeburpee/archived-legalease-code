/*
 * Copyright 2009 Keith Stevens 
 *
 * This file is part of the S-Space package and is covered under the terms and
 * conditions therein.
 *
 * The S-Space package is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation and distributed hereunder to you.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND NO REPRESENTATIONS OR WARRANTIES,
 * EXPRESS OR IMPLIED ARE MADE.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, WE MAKE
 * NO REPRESENTATIONS OR WARRANTIES OF MERCHANT- ABILITY OR FITNESS FOR ANY
 * PARTICULAR PURPOSE OR THAT THE USE OF THE LICENSED SOFTWARE OR DOCUMENTATION
 * WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER
 * RIGHTS.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

package edu.ucla.sspace.matrix;


/**
 * A collection of normalization techniques available on a {@code Matrix}.  Each
 * method provided will alter the values of a given matrix in place with the
 * values generated by the specified normalization technique.
 *
 * @author Keith Stevens
 */
public class Normalize {

    /**
     * A private constructor to make this class uninstantiable.
     */
    private Normalize() {}

    /**
     * Normalize the values of each row in {@code Matrix} to be normalized by
     * the length of each row.
     *
     * @param m The matrix to normalize.
     */
    public static void byRow(Matrix m) {
        for (int i = 0; i < m.rows(); ++i) {
            double rowSum = 0;
            for (int j = 0; j < m.columns(); ++j)
                rowSum += m.get(i,j);

            // Skip row whose sume is zero.
            if (rowSum == 0) 
                continue;
            for (int j = 0; j < m.columns(); ++j)
                m.set(i,j, m.get(i,j) / rowSum);
        }
    }

    /**
     * Normalize the values of each column in the {@code Matrix} to be
     * normalized by the length of each column.
     *
     * @param m The matrix to normalize.
     */
    public static void byColumn(Matrix m) {
        for (int i = 0; i < m.columns(); ++i) {
            double colSum = 0;
            for (int j = 0; j < m.rows(); ++j)
                colSum += m.get(j,i);

            // Skip columns whose sume is zero.
            if (colSum == 0) 
                continue;
            for (int j = 0; j < m.rows(); ++j)
                m.set(j,i, m.get(j,i) / colSum);
        }
    }

    /**
     * Normalize the values of each row in the {@code Matrix} to be
     * normalized by the l2 norm of each row.
     *
     * @param m The matrix to normalize.
     */
    public static void byLength(Matrix m) {
        for (int i = 0; i < m.rows(); ++i) {
            double rowSum = 0;
            for (int j = 0; j < m.columns(); ++j)
                rowSum += Math.pow(m.get(i,j), 2);
            rowSum = Math.sqrt(rowSum);

            // Skip rows whose l2 norm is 0.
            if (rowSum == 0) 
                continue;
            for (int j = 0; j < m.columns(); ++j)
                m.set(i,j, m.get(i,j) / rowSum);
        }
    }

    /**
     * Normalize the all the values values in the {@code Matrix} to be
     * normalized by the l2 norm of the entire {@code Matrix}.
     *
     * @param m The matrix to normalize.
     */
    public static void byMagnitude(Matrix m) {
        double totalMag = 0;
        for (int i = 0; i < m.rows(); ++i) {
            for (int j = 0; j < m.columns(); ++j) {
                totalMag += Math.pow(m.get(i, j), 2);
            }
        }
        totalMag = Math.sqrt(totalMag);

        // Skip normalization if the l2 norm is 0.
        if (totalMag == 0d)
            return;
        for (int i = 0; i < m.rows(); ++i) {
            for (int j = 0; j < m.columns(); ++j) {
                m.set(i, j, m.get(i, j) / totalMag);
            }
        }
    }

    /**
     * Normalize the values of the {@code Matrix} by using the Pearson
     * correlation.  This will give values between -1 and 1.  If {@code
     * saveNegatives} is is {@code true}, negative correlations will be saved,
     * and otherwise they are reduced to zero.
     *
     * @param m The {@code Matrix} to normalize.
     * @param saveNegatives If true, save all values, even if they are negative.
     */
    public static void byCorrelation(Matrix m, boolean saveNegatives) {
        double totalSum = 0;

        // Generate the total value in each row and column.
        double[] rowSums = new double[m.rows()];
        double[] colSums = new double[m.columns()];
        for (int i = 0; i < m.rows(); ++i) {
            for (int j = 0; j < m.columns(); ++j) {
                totalSum += m.get(i,j);
                colSums[j] += m.get(i,j);
                rowSums[i] += m.get(i,j);
            }
        }

        // Use the row and column totals to compute the correlation.
        for (int i = 0; i < m.rows(); ++i) {
            for (int j = 0; j< m.columns(); ++j) {
                double newVal =
                    (totalSum * m.get(i,j) - rowSums[i] * colSums[j]) /
                    Math.sqrt(rowSums[i] * (totalSum - rowSums[i]) *
                              colSums[j] * (totalSum - colSums[j]));

                // Store the computed value.
                if (saveNegatives)
                    m.set(i,j, newVal);
                else
                    m.set(i,j, newVal > 0 ? newVal : 0);
            }
        }
    }
}
